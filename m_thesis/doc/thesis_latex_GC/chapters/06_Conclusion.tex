\chapter{Summary, Future Work and Conclusion}

This chapter is divided into four sections. Section \ref{summary} presents a summary of the thesis. The contributions and importance of the work along with the limitations are discussed in \ref{disc}. Section \ref{futurework} outlines the possibilities for future work, and Section \ref{con} presents the conclusions drawn from the thesis.

\section{Summary of the Thesis} \label{summary}
The dynamic task update method introduced in this thesis is required for the Observer-Controller architecture used in the KIA4SM project. The implementation is done on the Genode Operating System Framework and the L4/Fiasco.OC microkernel. This thesis presented the lock-based and lock-free synchronization methods and their benefits in terms of \textit{implementation, read and write speed, security, deadlocks}. The lock-free methods, Read-Copy Update(RCU) and Software Transactional Memory (STM) were found to be better suited for this thesis work since they provide good read/write speed and prevent deadlocks.

The Genode OS framework has a recursive tree structure, and is used for building safe, secure and robust operating systems. It can be used with different microkernels. L4/Fiasco.OC was the preferred choice of microkernel for the KIA4Sm project, since it offers many features such as, paravirtualization and multi processor support. The L4/Fiasco.OC is a object capability system, where everything in the kernel is represented as an object and objects interact with each other through a kernel provided IPC mechanism. The thread execution in the kernel is divided between execution context, which takes care of execution parameters and scheduling context object, which holds scheduling parameters.

The design and implementation details of the Synchronization module are described in Chapter 4 and Chapter 5. The communication between the Controller and the Synchronization module is that of a producer-consumer relationship and the communication between these two modules is handled by a shared dataspace, which is synchronized by using the locks provided from Genode. The limitations in accessing the ready queue from the user-level application, led to the development of kernel module. The application interacts with the Genode API, which in turn calls the L4 layer. The L4 layer makes the flex pages for the threads that are sent from the Genode and sends them to the scheduler kernel object with an IPC call. The scheduler decides the right time for updating the ready queue and updates the threads. One option is to create a new ready queue list with the threads and exchange it with the actual ready queue. the other option is to update the existing ready queue.

Since the integration testing was not possible, only the individual components were tested. A Genode component was created to test the kernel module by extending the Genode's trace service.

\section{Discussion} \label{disc}
\subsection{Thesis Contribution}
This thesis has developed a method for updating the kernel ready queue. A user-level component was developed to handle the communication with the Controller and the kernel module handles the ready queue update mechanism. The thesis gives insights to the working environment of the L4/Fiasco.OC kernel and its interaction with the Genode OS framework. The thread creation model in the Genode OS is explored and the thread migration model of the L4/Fiasco.OC is explained to scheduling method of the L4/Fiasco.OC scheduler.

\subsection{Limitations}
Though proposed solution updates the task ready queue successfully, it has the following limitations. First, the user-level application handles each ready queue one at a time and has to wait till it acquires the lock to access the shared dataspace, which may lead to starvation of the threads. Second, the user-level Genode component cannot access the kernel ready queue list  directly or make calls to the L4 API layer of the kernel. This limits the scope of the user-level component. Though creating a new ready queue list to exchange with the actual ready queue takes place, the ready queue exchange mechanism, however doesn't ensure the thread execution. The current implementation of the kernel module is limited to work with fixed priority scheduler.

\section{Future Work}\label{futurework}
This section describes the ideas for future research to be done on this concept. Further investigations should be done to identify the best approach to integrate the Controller and the Synchronization module. The proposed idea for integration is that the Observer gathers data including the Genode thread ids to the Controller and the Controller has to take decisions on scheduling and make the corresponding thread ids available in the shared dataspace. The user-level Synchronization module can read this dataspace and update them to the ready queue using the kernel module. Furthermore, the kernel module must be extended to make it work with different types of schedulers.

The initial aim of the thesis was to develop a high-level component for the ready queue update. However, this had to be changed since the ready queue was not accessible from a high-level component. Further work should be carried out to find out if a user-level component can replace the kernel module's work. The communication between the user-level module and the kernel module involves many API calls. More research could be done on this regard to reduce the number of API calls.

\section{Conclusion}\label{con}
The Synchronization module developed in this thesis provides a working method for updating the threads to kernel ready queue. It serves as a good starting point for the \texttt{Observer-Controller} architecture's goal of having a user-level component for ready queue update.